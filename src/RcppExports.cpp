// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/EFL0Network.h"
#include <RcppEigen.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// scaleC
List scaleC(Eigen::MatrixXd X);
static SEXP _EFL0Network_scaleC_try(SEXP XSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type X(XSEXP);
    rcpp_result_gen = Rcpp::wrap(scaleC(X));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _EFL0Network_scaleC(SEXP XSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_EFL0Network_scaleC_try(XSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// maxLambdaLmC
double maxLambdaLmC(Eigen::MatrixXd X, Eigen::VectorXd y, double alpha, Eigen::VectorXd wbeta, int N0, int p);
static SEXP _EFL0Network_maxLambdaLmC_try(SEXP XSEXP, SEXP ySEXP, SEXP alphaSEXP, SEXP wbetaSEXP, SEXP N0SEXP, SEXP pSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type X(XSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type y(ySEXP);
    Rcpp::traits::input_parameter< double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type wbeta(wbetaSEXP);
    Rcpp::traits::input_parameter< int >::type N0(N0SEXP);
    Rcpp::traits::input_parameter< int >::type p(pSEXP);
    rcpp_result_gen = Rcpp::wrap(maxLambdaLmC(X, y, alpha, wbeta, N0, p));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _EFL0Network_maxLambdaLmC(SEXP XSEXP, SEXP ySEXP, SEXP alphaSEXP, SEXP wbetaSEXP, SEXP N0SEXP, SEXP pSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_EFL0Network_maxLambdaLmC_try(XSEXP, ySEXP, alphaSEXP, wbetaSEXP, N0SEXP, pSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// EnetLmC
List EnetLmC(Eigen::MatrixXd X, Eigen::VectorXd y, Eigen::VectorXd weights, double alpha, Eigen::VectorXd lambda, int nlambda, int ilambda, Eigen::VectorXd wbeta, Eigen::VectorXd wbeta2, int p, int N0, double thresh, int maxit, double thresh2);
static SEXP _EFL0Network_EnetLmC_try(SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP alphaSEXP, SEXP lambdaSEXP, SEXP nlambdaSEXP, SEXP ilambdaSEXP, SEXP wbetaSEXP, SEXP wbeta2SEXP, SEXP pSEXP, SEXP N0SEXP, SEXP threshSEXP, SEXP maxitSEXP, SEXP thresh2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type X(XSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type y(ySEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< int >::type nlambda(nlambdaSEXP);
    Rcpp::traits::input_parameter< int >::type ilambda(ilambdaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type wbeta(wbetaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type wbeta2(wbeta2SEXP);
    Rcpp::traits::input_parameter< int >::type p(pSEXP);
    Rcpp::traits::input_parameter< int >::type N0(N0SEXP);
    Rcpp::traits::input_parameter< double >::type thresh(threshSEXP);
    Rcpp::traits::input_parameter< int >::type maxit(maxitSEXP);
    Rcpp::traits::input_parameter< double >::type thresh2(thresh2SEXP);
    rcpp_result_gen = Rcpp::wrap(EnetLmC(X, y, weights, alpha, lambda, nlambda, ilambda, wbeta, wbeta2, p, N0, thresh, maxit, thresh2));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _EFL0Network_EnetLmC(SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP alphaSEXP, SEXP lambdaSEXP, SEXP nlambdaSEXP, SEXP ilambdaSEXP, SEXP wbetaSEXP, SEXP wbeta2SEXP, SEXP pSEXP, SEXP N0SEXP, SEXP threshSEXP, SEXP maxitSEXP, SEXP thresh2SEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_EFL0Network_EnetLmC_try(XSEXP, ySEXP, weightsSEXP, alphaSEXP, lambdaSEXP, nlambdaSEXP, ilambdaSEXP, wbetaSEXP, wbeta2SEXP, pSEXP, N0SEXP, threshSEXP, maxitSEXP, thresh2SEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// cvEnetLmC
List cvEnetLmC(Eigen::MatrixXd X, Eigen::VectorXd y, Eigen::VectorXd weights, double alpha, Eigen::VectorXd lambda, int nlambda, Eigen::VectorXd wbeta, Eigen::VectorXd wbeta2, int N, int p, double thresh, int maxit, Eigen::MatrixXd XF, Eigen::VectorXd yF, Eigen::VectorXd weightsF, int NF, double thresh2);
static SEXP _EFL0Network_cvEnetLmC_try(SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP alphaSEXP, SEXP lambdaSEXP, SEXP nlambdaSEXP, SEXP wbetaSEXP, SEXP wbeta2SEXP, SEXP NSEXP, SEXP pSEXP, SEXP threshSEXP, SEXP maxitSEXP, SEXP XFSEXP, SEXP yFSEXP, SEXP weightsFSEXP, SEXP NFSEXP, SEXP thresh2SEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type X(XSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type y(ySEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< double >::type alpha(alphaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type lambda(lambdaSEXP);
    Rcpp::traits::input_parameter< int >::type nlambda(nlambdaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type wbeta(wbetaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type wbeta2(wbeta2SEXP);
    Rcpp::traits::input_parameter< int >::type N(NSEXP);
    Rcpp::traits::input_parameter< int >::type p(pSEXP);
    Rcpp::traits::input_parameter< double >::type thresh(threshSEXP);
    Rcpp::traits::input_parameter< int >::type maxit(maxitSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type XF(XFSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type yF(yFSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weightsF(weightsFSEXP);
    Rcpp::traits::input_parameter< int >::type NF(NFSEXP);
    Rcpp::traits::input_parameter< double >::type thresh2(thresh2SEXP);
    rcpp_result_gen = Rcpp::wrap(cvEnetLmC(X, y, weights, alpha, lambda, nlambda, wbeta, wbeta2, N, p, thresh, maxit, XF, yF, weightsF, NF, thresh2));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _EFL0Network_cvEnetLmC(SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP alphaSEXP, SEXP lambdaSEXP, SEXP nlambdaSEXP, SEXP wbetaSEXP, SEXP wbeta2SEXP, SEXP NSEXP, SEXP pSEXP, SEXP threshSEXP, SEXP maxitSEXP, SEXP XFSEXP, SEXP yFSEXP, SEXP weightsFSEXP, SEXP NFSEXP, SEXP thresh2SEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_EFL0Network_cvEnetLmC_try(XSEXP, ySEXP, weightsSEXP, alphaSEXP, lambdaSEXP, nlambdaSEXP, wbetaSEXP, wbeta2SEXP, NSEXP, pSEXP, threshSEXP, maxitSEXP, XFSEXP, yFSEXP, weightsFSEXP, NFSEXP, thresh2SEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// softLmC
List softLmC(Eigen::VectorXd beta, Eigen::VectorXd betaSTD, double lambda1, Eigen::VectorXd wbeta, double lambda2_EFL0, Eigen::VectorXd ridgeC_EFL0, Eigen::MatrixXd X, Eigen::VectorXd weights, int N, int p);
static SEXP _EFL0Network_softLmC_try(SEXP betaSEXP, SEXP betaSTDSEXP, SEXP lambda1SEXP, SEXP wbetaSEXP, SEXP lambda2_EFL0SEXP, SEXP ridgeC_EFL0SEXP, SEXP XSEXP, SEXP weightsSEXP, SEXP NSEXP, SEXP pSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type betaSTD(betaSTDSEXP);
    Rcpp::traits::input_parameter< double >::type lambda1(lambda1SEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type wbeta(wbetaSEXP);
    Rcpp::traits::input_parameter< double >::type lambda2_EFL0(lambda2_EFL0SEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type ridgeC_EFL0(ridgeC_EFL0SEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type X(XSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< int >::type N(NSEXP);
    Rcpp::traits::input_parameter< int >::type p(pSEXP);
    rcpp_result_gen = Rcpp::wrap(softLmC(beta, betaSTD, lambda1, wbeta, lambda2_EFL0, ridgeC_EFL0, X, weights, N, p));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _EFL0Network_softLmC(SEXP betaSEXP, SEXP betaSTDSEXP, SEXP lambda1SEXP, SEXP wbetaSEXP, SEXP lambda2_EFL0SEXP, SEXP ridgeC_EFL0SEXP, SEXP XSEXP, SEXP weightsSEXP, SEXP NSEXP, SEXP pSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_EFL0Network_softLmC_try(betaSEXP, betaSTDSEXP, lambda1SEXP, wbetaSEXP, lambda2_EFL0SEXP, ridgeC_EFL0SEXP, XSEXP, weightsSEXP, NSEXP, pSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// cvHardLmC
List cvHardLmC(Eigen::VectorXd beta, Eigen::VectorXd betaSTD, Eigen::VectorXd cut, Eigen::VectorXd wbeta, Eigen::MatrixXd X, Eigen::VectorXd y, Eigen::VectorXd weights, int N, int p, Eigen::MatrixXd XF, Eigen::VectorXd yF, Eigen::VectorXd weightsF, int NF);
static SEXP _EFL0Network_cvHardLmC_try(SEXP betaSEXP, SEXP betaSTDSEXP, SEXP cutSEXP, SEXP wbetaSEXP, SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP NSEXP, SEXP pSEXP, SEXP XFSEXP, SEXP yFSEXP, SEXP weightsFSEXP, SEXP NFSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type betaSTD(betaSTDSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type cut(cutSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type wbeta(wbetaSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type X(XSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type y(ySEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< int >::type N(NSEXP);
    Rcpp::traits::input_parameter< int >::type p(pSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type XF(XFSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type yF(yFSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weightsF(weightsFSEXP);
    Rcpp::traits::input_parameter< int >::type NF(NFSEXP);
    rcpp_result_gen = Rcpp::wrap(cvHardLmC(beta, betaSTD, cut, wbeta, X, y, weights, N, p, XF, yF, weightsF, NF));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _EFL0Network_cvHardLmC(SEXP betaSEXP, SEXP betaSTDSEXP, SEXP cutSEXP, SEXP wbetaSEXP, SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP NSEXP, SEXP pSEXP, SEXP XFSEXP, SEXP yFSEXP, SEXP weightsFSEXP, SEXP NFSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_EFL0Network_cvHardLmC_try(betaSEXP, betaSTDSEXP, cutSEXP, wbetaSEXP, XSEXP, ySEXP, weightsSEXP, NSEXP, pSEXP, XFSEXP, yFSEXP, weightsFSEXP, NFSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// cvTrimLmC
List cvTrimLmC(Eigen::VectorXd beta, int nn, int nn2, Eigen::VectorXi loco, Eigen::MatrixXd X, Eigen::VectorXd y, Eigen::VectorXd weights, int N, int p, Eigen::MatrixXd XF, Eigen::VectorXd yF, Eigen::VectorXd weightsF, int NF);
static SEXP _EFL0Network_cvTrimLmC_try(SEXP betaSEXP, SEXP nnSEXP, SEXP nn2SEXP, SEXP locoSEXP, SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP NSEXP, SEXP pSEXP, SEXP XFSEXP, SEXP yFSEXP, SEXP weightsFSEXP, SEXP NFSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type beta(betaSEXP);
    Rcpp::traits::input_parameter< int >::type nn(nnSEXP);
    Rcpp::traits::input_parameter< int >::type nn2(nn2SEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXi >::type loco(locoSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type X(XSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type y(ySEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weights(weightsSEXP);
    Rcpp::traits::input_parameter< int >::type N(NSEXP);
    Rcpp::traits::input_parameter< int >::type p(pSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type XF(XFSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type yF(yFSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weightsF(weightsFSEXP);
    Rcpp::traits::input_parameter< int >::type NF(NFSEXP);
    rcpp_result_gen = Rcpp::wrap(cvTrimLmC(beta, nn, nn2, loco, X, y, weights, N, p, XF, yF, weightsF, NF));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _EFL0Network_cvTrimLmC(SEXP betaSEXP, SEXP nnSEXP, SEXP nn2SEXP, SEXP locoSEXP, SEXP XSEXP, SEXP ySEXP, SEXP weightsSEXP, SEXP NSEXP, SEXP pSEXP, SEXP XFSEXP, SEXP yFSEXP, SEXP weightsFSEXP, SEXP NFSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_EFL0Network_cvTrimLmC_try(betaSEXP, nnSEXP, nn2SEXP, locoSEXP, XSEXP, ySEXP, weightsSEXP, NSEXP, pSEXP, XFSEXP, yFSEXP, weightsFSEXP, NFSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _EFL0Network_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("List(*scaleC)(Eigen::MatrixXd)");
        signatures.insert("double(*maxLambdaLmC)(Eigen::MatrixXd,Eigen::VectorXd,double,Eigen::VectorXd,int,int)");
        signatures.insert("List(*EnetLmC)(Eigen::MatrixXd,Eigen::VectorXd,Eigen::VectorXd,double,Eigen::VectorXd,int,int,Eigen::VectorXd,Eigen::VectorXd,int,int,double,int,double)");
        signatures.insert("List(*cvEnetLmC)(Eigen::MatrixXd,Eigen::VectorXd,Eigen::VectorXd,double,Eigen::VectorXd,int,Eigen::VectorXd,Eigen::VectorXd,int,int,double,int,Eigen::MatrixXd,Eigen::VectorXd,Eigen::VectorXd,int,double)");
        signatures.insert("List(*softLmC)(Eigen::VectorXd,Eigen::VectorXd,double,Eigen::VectorXd,double,Eigen::VectorXd,Eigen::MatrixXd,Eigen::VectorXd,int,int)");
        signatures.insert("List(*cvHardLmC)(Eigen::VectorXd,Eigen::VectorXd,Eigen::VectorXd,Eigen::VectorXd,Eigen::MatrixXd,Eigen::VectorXd,Eigen::VectorXd,int,int,Eigen::MatrixXd,Eigen::VectorXd,Eigen::VectorXd,int)");
        signatures.insert("List(*cvTrimLmC)(Eigen::VectorXd,int,int,Eigen::VectorXi,Eigen::MatrixXd,Eigen::VectorXd,Eigen::VectorXd,int,int,Eigen::MatrixXd,Eigen::VectorXd,Eigen::VectorXd,int)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _EFL0Network_RcppExport_registerCCallable() { 
    R_RegisterCCallable("EFL0Network", "_EFL0Network_scaleC", (DL_FUNC)_EFL0Network_scaleC_try);
    R_RegisterCCallable("EFL0Network", "_EFL0Network_maxLambdaLmC", (DL_FUNC)_EFL0Network_maxLambdaLmC_try);
    R_RegisterCCallable("EFL0Network", "_EFL0Network_EnetLmC", (DL_FUNC)_EFL0Network_EnetLmC_try);
    R_RegisterCCallable("EFL0Network", "_EFL0Network_cvEnetLmC", (DL_FUNC)_EFL0Network_cvEnetLmC_try);
    R_RegisterCCallable("EFL0Network", "_EFL0Network_softLmC", (DL_FUNC)_EFL0Network_softLmC_try);
    R_RegisterCCallable("EFL0Network", "_EFL0Network_cvHardLmC", (DL_FUNC)_EFL0Network_cvHardLmC_try);
    R_RegisterCCallable("EFL0Network", "_EFL0Network_cvTrimLmC", (DL_FUNC)_EFL0Network_cvTrimLmC_try);
    R_RegisterCCallable("EFL0Network", "_EFL0Network_RcppExport_validate", (DL_FUNC)_EFL0Network_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_EFL0Network_scaleC", (DL_FUNC) &_EFL0Network_scaleC, 1},
    {"_EFL0Network_maxLambdaLmC", (DL_FUNC) &_EFL0Network_maxLambdaLmC, 6},
    {"_EFL0Network_EnetLmC", (DL_FUNC) &_EFL0Network_EnetLmC, 14},
    {"_EFL0Network_cvEnetLmC", (DL_FUNC) &_EFL0Network_cvEnetLmC, 17},
    {"_EFL0Network_softLmC", (DL_FUNC) &_EFL0Network_softLmC, 10},
    {"_EFL0Network_cvHardLmC", (DL_FUNC) &_EFL0Network_cvHardLmC, 13},
    {"_EFL0Network_cvTrimLmC", (DL_FUNC) &_EFL0Network_cvTrimLmC, 13},
    {"_EFL0Network_RcppExport_registerCCallable", (DL_FUNC) &_EFL0Network_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_EFL0Network(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
