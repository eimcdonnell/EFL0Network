% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EFL0.R
\name{EFL0}
\alias{EFL0}
\title{EFL0}
\usage{
EFL0(
  x,
  y,
  weights,
  lambda = NULL,
  nlambda = 50,
  rlambda = NULL,
  wbeta = rep(1, ncol(x)),
  nfolds = 1,
  foldid = NULL,
  iEFL0 = FALSE,
  lambda2_EFL0 = NULL,
  ridgeC_EFL0 = NULL,
  iL0 = TRUE,
  ncutB = 10,
  isd = FALSE,
  iysd = FALSE,
  keep.beta = FALSE,
  thresh = 1e-06,
  maxit = 1e+05,
  print_test = TRUE
)
}
\arguments{
\item{x}{input matrix. Each row is an observation vector.}

\item{y}{response vector.}

\item{weights}{vector of observation-level weights.}

\item{lambda}{a use-supplied vector of candidate lambda values. If
\code{NULL} (default), a sequence of \code{lambda} is generated based on
\code{nlambda} and \code{rlambda}. Supplying a value of \code{lambda}
overrides this.}

\item{nlambda}{number of \code{lambda} values. Default is 50.}

\item{rlambda}{fraction of \code{lambda.max} to determine the smallest value
for \code{lambda}. The default is \code{rlambda = 0.0001} when the number of
observations is larger than or equal to the number of variables; otherwise,
\code{rlambda = 0.01}.}

\item{wbeta}{vector of non-negative coefficient-specific adaptive lasso
weights for the L1 penalty. Default is 1 for all coefficients.}

\item{nfolds}{number of folds. With \code{nfolds = 1} and
\code{foldid = NULL} by default, cross-validation is not performed.
Specifying \code{foldid} overrides \code{nfolds}.}

\item{foldid}{an optional vector of values between 1 and \code{nfolds}
specifying which fold each observation is in.}

\item{iEFL0}{logical indicator of whether to include the two EFL0 penalties
(L2 and L0). Default is \code{FALSE}.}

\item{lambda2_EFL0}{vector of candidate lambda2 values for the L2 penalty of
EFL0. Default is \code{NULL}.}

\item{ridgeC_EFL0}{vector of coefficient-specific constant C values for the
L2 penalty of EFL0. Default is\code{NULL}.}

\item{iL0}{logical flag for performing L0-norm via hard-thresholding. Default
is \code{TRUE}.}

\item{ncutB}{number of cuts to try for hard-thresholding. Default is 10.}

\item{isd}{logical flag for outputting standardized coefficients. \code{x} is
always standardized prior to fitting the model. Default is
\code{isd = FALSE}, returning \eqn{\beta} on the original scale.}

\item{iysd}{logical flag for standardizing \code{y} prior to computation. The
returning coefficients are always based the original \code{y}
(unstandardized). Default is \code{isd = FALSE}.}

\item{keep.beta}{logical flag for returning estimates for all \code{lambda}
values. Default is \code{FALSE}.}

\item{thresh}{convergence threshold for coordinate descent. Default value is
\code{1E-6}.}

\item{maxit}{Maximum number of iterations for coordinate descent. Default is
\code{10^5}.}

\item{print_test}{logical indicator for whether to print test output. Default
is \code{FALSE}.}
}
\value{
A list containing the following:
\item{a}{the intercept}
\item{Beta}{a sparse Matrix of coefficients after L1 penalization.}
\item{Beta_soft}{coefficients after additionally performing soft-thresholding
for \code{iEFL0 = TRUE}}
\item{Beta0}{coefficients after additionally performing L0-norm for
\code{iL0 = TRUE}}
\item{fit}{a data.frame containing \code{lambda} and the number of non-zero
coefficients \code{nzero}.
With cross-validation, additional results are reported, such as average
cross-validation partial likelihood \code{cvm} and its standard error
\code{cvse}, and \code{index} with `*' indicating the minimum \code{cvm}.}
\item{fit0}{a data.frame containing \code{lambda}, \code{cvm} and
\code{nzero} based on \code{iL0 = TRUE}. \code{cvm} in \code{fit0} may be
different from \code{cvm} in \code{fit}, because of hard-thresholding.}
\item{lambda.opt}{value of \code{lambda} based on \code{iL0 = TRUE}.}
\item{flag}{convergence flag (for internal debugging). \code{flag = 0} means
converged.}
}
\description{
Elastic Fuse L0 (EFL0) regression model.
}
