# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

scaleC <- function(X) {
    .Call('_EFL0Network_scaleC', PACKAGE = 'EFL0Network', X)
}

maxLambdaLmC <- function(X, y, alpha, wbeta, N0, p) {
    .Call('_EFL0Network_maxLambdaLmC', PACKAGE = 'EFL0Network', X, y, alpha, wbeta, N0, p)
}

EnetLmC <- function(X, y, weights, alpha, lambda, nlambda, ilambda, wbeta, wbeta2, p, N0, thresh, maxit, thresh2) {
    .Call('_EFL0Network_EnetLmC', PACKAGE = 'EFL0Network', X, y, weights, alpha, lambda, nlambda, ilambda, wbeta, wbeta2, p, N0, thresh, maxit, thresh2)
}

cvEnetLmC <- function(X, y, weights, alpha, lambda, nlambda, wbeta, wbeta2, N, p, thresh, maxit, XF, yF, weightsF, NF, thresh2) {
    .Call('_EFL0Network_cvEnetLmC', PACKAGE = 'EFL0Network', X, y, weights, alpha, lambda, nlambda, wbeta, wbeta2, N, p, thresh, maxit, XF, yF, weightsF, NF, thresh2)
}

softLmC <- function(beta, betaSTD, lambda1, wbeta, lambda2_EFL0, ridgeC_EFL0, X, weights, N, p) {
    .Call('_EFL0Network_softLmC', PACKAGE = 'EFL0Network', beta, betaSTD, lambda1, wbeta, lambda2_EFL0, ridgeC_EFL0, X, weights, N, p)
}

cvHardLmC <- function(beta, betaSTD, cut, wbeta, X, y, weights, N, p, XF, yF, weightsF, NF) {
    .Call('_EFL0Network_cvHardLmC', PACKAGE = 'EFL0Network', beta, betaSTD, cut, wbeta, X, y, weights, N, p, XF, yF, weightsF, NF)
}

cvTrimLmC <- function(beta, nn, nn2, loco, X, y, weights, N, p, XF, yF, weightsF, NF) {
    .Call('_EFL0Network_cvTrimLmC', PACKAGE = 'EFL0Network', beta, nn, nn2, loco, X, y, weights, N, p, XF, yF, weightsF, NF)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('_EFL0Network_RcppExport_registerCCallable', PACKAGE = 'EFL0Network')
})
